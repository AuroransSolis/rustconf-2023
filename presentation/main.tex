%\documentclass[aspectratio = 169]{beamer}
\documentclass{beamer}

\usepackage{emoji}
\usepackage{fontspec}
\usepackage{framed}
\usepackage{hyperref}
\usepackage{iftex}
\usepackage{minted}
\usepackage{svg}
\usepackage{tabularray}
\usepackage{tikz}
\usepackage{ulem}
\usepackage{xcolor}

\ifpdftex
	\usepackage[utf8x]{inputenc}
\fi

%
% Document setup
%

% hyperref
\AtBeginDocument{
	\hypersetup{
		pdftitle = {Anything you can do, I can do worse with `macro\_rules!`},
		pdfauthor = {Aurorans Solis},
	}
}

% Fonts
\newfontfamily\jetbrainsmono{JetBrains Mono}[NFSSFamily = JetBrains Mono]
\setemojifont{TwemojiMozilla}
%\setmonofont{JetBrains Mono}

% Beamer theme
\usetheme[nofirafonts]{focus}
%\usetheme{focus}
\setsansfont{Fira Sans}
\setmonofont{Fira Mono}

% Title
\title{Anything you can do, I can do worse with {\color{macrorulescolor}\texttt{macro\_rules!}}}
\author{Aurorans Solis}
\date{}
\titlegraphic{\includegraphics[scale = 0.15]{profile-pic.png}}

%
% Package configuration
%

% Minted
\setminted{
	bgcolor = lightergrey,
	fontfamily = JetBrains Mono,
	fontsize = \tiny,
	highlightcolor = blue9,
	linenos = true,
	tabsize = 4,
	numberblanklines = true,
	numbersep = 2pt,
}
\usemintedstyle{default}

% 1. native
% 2. material
% 3. paraiso-dark
% 4. one-dark
% 6. github-dark

% tikz
\usetikzlibrary{arrows, automata, positioning}

%
% Other
%

% Colours
\definecolor{lightergrey}{RGB}{230, 230, 230}
\definecolor{macrorulescolor}{RGB}{86, 156, 214}
\definecolor{lightgrey}{RGB}{212, 212, 212}
\definecolor{fragspeccolor}{RGB}{156, 220, 254}
\definecolor{ifcolor}{RGB}{197, 134, 192}
\definecolor{errwhite}{RGB}{255, 255, 255}
\definecolor{errredcolour}{RGB}{255, 0, 0}
\definecolor{errgreencolour}{RGB}{0, 255, 0}
\definecolor{errbluecolour}{RGB}{24, 135, 241}

% Extra commands
\newcommand{\fragspec}[1]{{\color{lightgrey}:}{\color{fragspeccolor}#1}}
\newcommand{\rustkeyword}[1]{{\color{ifcolor}\texttt{#1}}}
\newcommand{\rusttoken}[1]{{\color{lightgrey}\texttt{#1}}}
\newcommand{\eths}{\emoji{two-hearts}}
\newcommand{\maincolour}[1]{\colorbox{main}{#1}}
\newcommand{\errwhite}[1]{{\color{errwhitecolour}#1}}
\newcommand{\errred}[1]{{\color{errredcolour}#1}}
\newcommand{\errgreen}[1]{{\color{errgreencolour}#1}}
\newcommand{\errblue}[1]{{\color{errbluecolour}#1}}

\begin{document}
	\begin{frame}
		\maketitle
	\end{frame}

	\section*{The Horrors}
	\begin{frame}{(:}
		\centering
		\includesvg[
			width = \linewidth,
			height = 0.8\textheight,
			inkscape = true,
			inkscapelatex = true,
			inkscapeformat = pdf,
			inkscapearea = page,
		]{time-1.svg}
	\end{frame}

	\begin{frame}{???}
		\centering
		\includesvg[
			width = \linewidth,
			height = 0.8\textheight,
			inkscape = true,
			inkscapelatex = true,
			inkscapeformat = pdf,
			inkscapearea = page,
		]{time-2.svg}
	\end{frame}

	\begin{frame}{!!!}
		\centering
		\includesvg[
			width = \linewidth,
			height = 0.8\textheight,
			inkscape = true,
			inkscapelatex = true,
			inkscapeformat = pdf,
			inkscapearea = page,
		]{time-3.svg}
	\end{frame}

	\begin{frame}{(:<}
		It's not snacktime anymore. It's crimetime.

		\pause

		We're going to define traits using XML.
	\end{frame}

	\subsection{Start of the evil arc}
	\begin{frame}[fragile]{(:<}
		We're going to take this trait:

		\begin{minted}[autogobble]{rust}
			pub trait Foo<const BAR: usize>: Baz {
				type Baq: Qux;
				const QUUX: Self::Baq;
				fn corge<Grault, Garply>(waldo: Grault) -> Garply;
			}
		\end{minted}
	\end{frame}

	\begin{frame}[fragile]{(:<}
		And turn it into this XML:
		\begin{center}
			\begin{minipage}{0.45\linewidth}
				\begin{minted}[autogobble]{xml}
					<trait>
						<name>Foo</name>
						<vis>pub</vis>
						<bounds>
							<const>
								<name>BAR</name>
								<type>usize</type>
							</const>
							<req>Baz</req>
						</bounds>
						<assoctype>
							<name>Baq</name>
							<bounds>
								<req>Qux</req>
							</bounds>
						</assoctype>
						<assocconst>
							<name>QUUX</name>
							<type>Self::Baq</type>
						</assocconst>
				\end{minted}
			\end{minipage}
			\hfill
			\begin{minipage}{0.45\linewidth}
				\begin{minted}[autogobble, firstnumber = 21]{xml}
						<assocfn>
							<name>corge</name>
							<bounds>
								<type>
									<name>Grault</name>
								</type>
								<type>
									<name>Garply</name>
								</type>
							</bounds>
							<args>
								<arg>
									<name>waldo</name>
									<type>Grault</type>
								</arg>
							</args>
							<ret>Garply</ret>
						</assocfn>
					</trait>
				\end{minted}
			\end{minipage}
		\end{center}

		\pause

		If you're asking, ``Why? Why would you do this to us?'' you're asking an excellent question.
		\pause I will not answer it.
	\end{frame}

	\subsection{what}
	\begin{frame}{auro no please stop}
		See the better question is, ``Ooh, how did you do that?'' \\

		\pause

		Let's take a look, shall we?
	\end{frame}

	\begin{frame}
		These are the places we'll look at:

		\small
		\begin{itemize}
			\item Internal rules:
			\begin{itemize}
				\item \path{trait_xml_macro.rs:9}, \path{trait_xml_macro.rs:37}
				\item \path{assoc_fn.rs:1618}, \path{assoc_fn.rs:1649}, \path{assoc_fn.rs:1680},
				\path{assoc_fn.rs:1711}
			\end{itemize}
			\pause
			\item Incremental TT muncher: \path{vis.rs:58}
			\pause
			\item Push-down accumulation: \path{type_ty.rs:116}
			\pause
			\item TT bundling (and unbundling): \path{assoc_type.rs:88},
			\path{trait_xml_macro.rs:336},
			\path{trait_xml_macro.rs:823}
			\pause
			\item Callback framework: \path{trait_xml_macro.rs:87},
			\path{name_ident.rs:92},
			\path{trait_xml_macro.rs:261}
		\end{itemize}
	\end{frame}

	\section[Review of macro\_rules!]{Review of {\color{macrorulescolor}\texttt{macro\_rules!}}}
	\subsection{Why macros?}
	\begin{frame}{Why macros?}
		Turns out that metaprogramming is pretty cool actually \\

		\begin{itemize}
			\item Repeat lots of similar but not quite identical things
			\pause
			\item Define new grammars that get expanded to valid Rust
			\pause
			\item Confuse everyone (including yourself!)
		\end{itemize}
	\end{frame}

	\subsection[What is a macro\_rules!]{What is a {\color{macrorulescolor}\texttt{macro\_rules!}}?}
	\begin{frame}{What is a {\color{macrorulescolor}\texttt{macro\_rules!}}?}
		Declarative macros (the ones we care about for this presentation) are sort of like functions
		on the AST. \\

		\pause

		We try to match on certain AST patterns (rules) against the input. \\

		\pause

		Rules are tried in order from top to bottom. \\

		\pause

		We have fragments and fragment specifiers to allow for general AST node input but constrain
		what form that input is allowed to take. \\

		\pause

		We also have repetition specifiers for:
		\begin{itemize}
			\item zero or one (\texttt{?})
			\item zero or more (\texttt{*})
			\item one or more (\texttt{+})
		\end{itemize}
	\end{frame}

	\subsection{What are our AST node types, a.k.a. fragment specifiers?}
	\begin{frame}{Fragment specifier types}
		Rust has these fragment specifier types:
		\begin{center}
			\begin{tblr}{
					colspec = cccc,
					rowspec = cccc,
					row{1-4} = {bg = main},
				}
				\fragspec{item}
					& \fragspec{block}
					& \fragspec{stmt}
					& \fragspec{pat\_param} \\
				\fragspec{pat}
					& \fragspec{expr}
					& \fragspec{ty}
					& \fragspec{ident} \\
				\fragspec{path}
					& \eths\fragspec{tt}\eths
					& \fragspec{meta}
					& \fragspec{lifetime} \\
				\empty{}
					& \fragspec{vis}
					& \fragspec{literal}
					& \empty{}
			\end{tblr}
		\end{center}
		Each of these, except \maincolour{\fragspec{tt}} are subject to regular Rust parsing rules.
		\\

		\pause

		There are also some limitations on what can come after certain fragment specifiers -- follow
		set ambiguity restrictions
		\begin{itemize}
			\item \maincolour{\fragspec{expr}} and \maincolour{\fragspec{stmt}} can only be followed
			by \texttt{=>}, \texttt{,}, or \texttt{;}

			\item \maincolour{\fragspec{pat\_param}} can only be followed by \texttt{=>},
			\texttt{,}, \texttt{=}, \texttt{|}, \rustkeyword{if}, or \rustkeyword{in}

			\item etc.
		\end{itemize}
	\end{frame}

	\subsection{Fragment Specifier Composition}
	\begin{frame}{Composition}
		Fragment specifiers can be composed into other fragment specifiers. For example, a
		\maincolour{\fragspec{ident}} and \maincolour{\fragspec{expr}} can be composed into a
		\maincolour{\fragspec{stmt}}. \\

		\pause

		The reverse is \textbf{NOT} true.
		\begin{center}
			\ttfamily
			\begin{tabular}{cc}
				\maincolour{\color{white}\fragspec{ident}, \fragspec{expr} => \fragspec{stmt}} =
				& \emoji{check-mark} \\
				\maincolour{\color{white}\fragspec{stmt} => \fragspec{ident}, \fragspec{expr}} =
				& \emoji{cross-mark}
			\end{tabular}
		\end{center}

		\pause

		However, \maincolour{\fragspec{tt}} tends to be the most flexible option for these sorts of
		operations.
	\end{frame}

	\begin{frame}[fragile]{Composition}
		\begin{minted}[autogobble]{rust}
macro_rules! me_reaping {
	($let:tt $lhs:tt $equal:tt $rhs:tt) => {
		// compose `:tt`s into a `:stmt`
		me_reaping!(@matchstmt $let $lhs $equal $rhs)
	};
	(@matchstmt $stmt:stmt) => {
		$stmt
	};
}

macro_rules! me_sowing {
	($stmt:stmt) => {
		// attempt to break a `:stmt` back into component `:tt`s
		me_reaping!($stmt);
	}
}

fn main() {
	me_reaping!(let haha = "yes!!!");
	println!("{haha}");
	me_sowing!(let well_this = "sucks ):");
	println!("{well_this}");
}
		\end{minted}
	\end{frame}

	\begin{frame}{Composition}
		That gives the following error message:
		\begin{center}
			\colorbox{lightergrey}{
				\ttfamily
				\scriptsize
				\parbox{0.9\textwidth}{%
					\errred{error}: unexpected end of macro invocation\\
					\phantom{xx}\errblue{-->} src/main.rs:14:26\\
					\phantom{xxx}\errblue{|}\\
					\phantom{x}\errblue{1  |} macro\_rules! me\_reaping \{\\
					\phantom{xxx}\errblue{| ----------------------- when calling this macro}\\
					\errblue{...}\\
					\errblue{14 |}         me\_reaping!(\$stmt);\\
					\phantom{xxx}\errblue{|}\phantom{xxxxxxxxxxxxxxxxxx}\errred{\^{} missing tokens
						in macro arguments}\\
					\phantom{xxx}\errblue{|}\\
					\errgreen{note}: while trying to match meta-variable `\$lhs:tt`\\
					\phantom{xx}\errblue{-->} src/main.rs:2:14\\
					\phantom{xxx}\errblue{|}\\
					\phantom{x}\errblue{2  |}\phantom{xxxxx}(\$let:tt \$lhs:tt \$equal:tt \$rhs:tt)
						=> \{
					\phantom{xxx}\errblue{|}\phantom{xxxxxxxxxxxxxx}\errgreen{\^{}\^{}\^{}\^{}\^{}%
						\^{}\^{}}
				}
			}
		\end{center}

		\pause

		This is definitely all the magic stuff we will do with token composition (lies!)
	\end{frame}

	\begin{frame}{Main Restrictions}
		There's two main restrictions that I've come across that aren't super obvious at first:
		\pause
		\begin{enumerate}
			\item No significant whitespace
			\pause
			\item No matching tokens (generically, at least, without a bunch more macros)
		\end{enumerate}
	\end{frame}

	\section{Main Useful Patterns}
	\subsection{Overview}
	\begin{frame}{Overview}
		There are \sout{four}six Big Lads of the Macropalypse:
		\begin{itemize}
			\item Recursion
			\begin{itemize}
				\item of course macros can call themselves!
			\end{itemize}

			\pause

			\item Internal rules
			\begin{itemize}
				\item these are branches that generally shouldn't be called by users\
			\end{itemize}

			\pause

			\item Incremental TT munchers
			\begin{itemize}
				\item grabs chunks off the front end of the list of inputs
			\end{itemize}

			\pause

			\item Push-down accumulation
			\begin{itemize}
				\item holds tokens in a list for later expansion
			\end{itemize}

			\pause

			\item TT bundling
			\begin{itemize}
				\item boils down to grouping multiple tokens into a single list
			\end{itemize}

			\pause

			\item Callbacks
			\begin{itemize}
				\item workaround to let you pass the expansion of one macro as input to another*
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}{Overview}
		Let's look at each of these in turn, but first, disclaimers.

		\pause

		\begin{itemize}
			\item You're going to hear and see, ``You've seen this already in this presentation!''
				a lot.

			\pause

			\item<3->
				\only<3>{
					Yes, these patterns (in combination) will let you parse just about anything.
				}
				\only<4->{
					\sout{Yes, these patterns (in combination) will let you parse just about
					anything.} {\errred{STOP STOP STOP}}
				}

			\pause

			\item Recursion is \textbf{THE} building block for macros using the aforementioned
				patterns, so for big inputs you may end up needing
				{\small\texttt{\#![recursion\_limit = "a very big number"]}}.
				\pause
				And a long time to compile.
				\pause
				And a lot of memory.
		\end{itemize}
	\end{frame}

	\begin{frame}{Overview}
		Let's look at each of these in turn, but first, disclaimers.

		\begin{itemize}
			\item Declarative macros can be (and often are) very difficult to debug.

			\pause

			\item Maintenance of big macros is\dots{} oh boy.

			\pause

			\item All that said, these patterns can be leveraged to simplify some things quite a
				lot.

			\pause

			\item This talk is mostly going to be cursed stuff, however, I'll also talk about a few
			ways I've used these patterns in my own work and also on how to make things a little
			less cursed.
		\end{itemize}
	\end{frame}

	\subsection{Recursion}
	\begin{frame}[fragile]{Recursion my beloved}
		You've seen this already in this presentation! \\

		This is the tool that every other pattern mentioned uses to work.

		\begin{minted}[autogobble, highlightlines = {4}]{rust}
macro_rules! me_reaping {
	($let:tt $lhs:tt $equal:tt $rhs:tt) => {
		// Recursive call to `me_reaping`
		me_reaping!(@matchstmt $let $lhs $equal $rhs)
	};
	(@matchstmt $stmt:stmt) => {
		$stmt
	};
}

fn main() {
	me_reaping!(let haha = "yes!!!");
	println!("{haha}");
	// no sowing (:<
}
		\end{minted}
	\end{frame}

	\subsection{Internal Rules}
	\begin{frame}[fragile]{Internal rules my beloved}
		You've seen this already in this presentation! Two slides prior, even! \\

		As said previously, you generally don't want users calling these rules. Usually they're used
		as a helper to grab new kinds of tokens or to specify a certain mode of parsing.

		\begin{minted}[autogobble, highlightlines = {6}]{rust}
macro_rules! me_reaping {
	($let:tt $lhs:tt $equal:tt $rhs:tt) => {
		me_reaping!(@matchstmt $let $lhs $equal $rhs)
	};
	// PATTERNS: internal rule to grab a statement
	(@matchstmt $stmt:stmt) => {
		$stmt
	};
}

fn main() {
	me_reaping!(let haha = "yes!!!");
	println!("{haha}");
	// no sowing (:<
}
		\end{minted}
	\end{frame}

	\begin{frame}{Internal rules my beloved}
		Not all internal rules start with \texttt{@something}! Internal rules are just any rules
		that users are not expected to call but are used at some intermediate stage in macro
		expansion. \\

		Useful in a couple ways
		\begin{itemize}
			\item Help avoid polluting crate namespace
			\begin{itemize}
				\item Each internal rule \emph{could} be its own macro, but those would also have to
					be marked with \texttt{\#[macro\_export]}
			\end{itemize}

			\item Can be used to set ``modes''
			\begin{itemize}
				\item Useful for parsing context-sensitive things
			\end{itemize}
		\end{itemize}
	\end{frame}

	\subsection{Incremental TT munchers}
	\begin{frame}[fragile]{Incremental TT munchers my beloved}
		You haven't seen this one already in this presentation! Surprise! \\

		With these you typically look to grab an expected pattern including some inputs.

		\begin{minted}[autogobble, highlightlines = {2, 5}]{rust}
macro_rules! munch_and_crunch {
	() => {
		println!("empty!");
	};
	($first:tt $($rest:tt)*) => {
		println!(concat!("munched: ", stringify!($first)));
		munch_and_crunch!($($rest)*);
	};
}

fn main() {
	munch_and_crunch!(foo bar baz baq);
	munch_and_crunch!(foo bar [baz baq]);
}
		\end{minted}

		This one is very simple, but \path{all-unique} in the repo shows a slightly more interesting
		example of how to apply a pure TT muncher.
	\end{frame}

	\subsection{Push-down Accumulation}
	\begin{frame}[fragile]{Push-down accumulation my beloved}
		This one hasn't been shown in this presentation yet! \\

		Frequently used with incremental TT munchers for the purpose of holding tokens that have
		been munched. For example:
		\begin{minted}[autogobble]{rust}
macro_rules! reverse_tokens {
	(@rev [$first:tt$(, $rest:tt)*] [$($rev:tt),*]) => {
		reverse_tokens! {
			@rev [$($rest),*][$first $(, $rev)*]
		}
	};
	(@rev [] [$($rev:tt),*]) => {
		$($rev)*
	};
	($($tt:tt)+) => {
		reverse_tokens! {
			@rev [$($tt),+] []
		}
	};
}

fn main() {
	reverse_tokens! {
		;0 = foo let
	}
	println!("{foo}");
}
		\end{minted}
	\end{frame}

	\subsection{TT Bundling}
	\begin{frame}[fragile]{TT bundling my beloved}
		This one hasn't shown up yet either! \\

		TT bundling is a sort of special case for composition, except this time we \textit{can}
		actually reverse it! \\

		Multiple tokens $\Rightarrow$ \texttt{[]}-list (\fragspec{tt})

		Let me show you what I mean.
	\end{frame}

	\begin{frame}[fragile]{TT bundling}
		\path{tt-bundling/src/main.rs}:
		\inputminted[autogobble, linenos]{rust}{../tt-bundling/src/main.rs}
	\end{frame}

	\subsection{Callbacks}
	\begin{frame}[fragile]{Callbacks my beloved}
		Very very generally, a callback looks something like this:

		\begin{minted}[autogobble]{rust}
macro_rules! callback {
	($callback:ident( $($args:tt)* )) => {
		$callback!( $($args)* )
	};
}

fn main() {
	callback!(callback(println("Yes, this *was* unnecessary.")));
}
		\end{minted}

		\pause

		Maybe these don't seem super useful, but they're great for being able to reuse one macro in
		multiple places.\pause{} As long as you have a consistent framework for calling your macros.
	\end{frame}



	\section{Debugging}
	\begin{frame}[fragile]{how???}
		If you're defining items outside of functions, how do you debug things? \\

		\pause

		What do when no \mintinline{rust}{println!}? \\

		\pause

		Introducing your new best friend:
		\begin{minted}[autogobble]{rust}
			const _: &str = stringify!($tokens);
			// also
			const _: &str = concat!($(stringify($tokens)),*);
		\end{minted}
	\end{frame}

	\begin{frame}[fragile]{Pretend println}
		You can see some residue from me debugging things and creating examples for documentation
		in \path{trait_xml_macro.rs}:
		\inputminted[
			firstline = 361,
			lastline = 383,
			highlightlines = {368},
		]{rust}{../trait-xml/src/trait_xml_macro.rs}
	\end{frame}

	\begin{frame}[fragile]{No rules expected the token\dots}
		``But Auro! My macro just plain doesn't work! I can't use \mintinline{rust}{const _}.'' \\

		Yes you can.

		\begin{minted}[autogobble]{rust}
			macro_rules! this_fails_somehow {
				// a bunch of rules up here...

				// ...and then at the end:
				($($all:tt)*) => {
					const _: &str = concat!($(stringify!($all)),*);
				};
			}
		\end{minted}

		This shows you the input as a string so you can try and figure out what's going wrong. \\

		It's also only matched if no other branch matches.
	\end{frame}

	\begin{frame}[fragile]{No rules expected the token\dots}
		Another thing you can do to keep \texttt{\errred{error}: no rules expected the token} from
		coming up is by just\dots{} making rules that expect the token/those tokens. \\

		\pause

		My XML parsing macros do this a bunch - if you give them an invalid input, a lot of the
		time it'll expand to a \texttt{compile\_error!}, e.g. in \texttt{lifetime.rs}:
		\inputminted[firstline = 342, lastline = 354]{rust}{../trait-xml/src/lifetime.rs}
	\end{frame}

	\begin{frame}{Other things}
		Some other suggestions to help you on your way (that sound a lot like general programming
		advice):
		\begin{itemize}
			\item Use descriptive names for rules, helper tokens, and fragments
			\item Don't worry about excessive complexity in a single rule -- just try to keep the
				depth of recursion down if you can
			\item Don't be afraid to make another macro, especially if it can be reused in other
				places
			\item If you need more steps to finish parsing, add them. Nobody needs to see all your
				internal rules but you (:
		\end{itemize}
	\end{frame}

	\begin{frame}{Materials}
		The materials for this talk are available on GitHub and GitLab at
		\texttt{AuroransSolis/rustconf-2023.git}.
	\end{frame}
\end{document}
